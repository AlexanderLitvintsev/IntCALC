/************************************************
Этот модуль сгенерирован транслятором AlgoPascal.
************************************************/

#include "ap.h"
#include "svd.h"
/*************************************************************************
Сингулярное разложение прямоугольной матрицы.

Алгоритм вычисляет сингулярное разложение матрицы размером MxN:
A = U * S * V^T

Алгоритм находит сингулярные значения и, опционально,  матрицы  U  и  V^T.
При этом возможно как нахождение первых  min(M,N)  столбцов  матрицы  U  и
строк матрицы V^T (сингулярных векторов), так и  полных  матриц  U  и  V^T
(размером MxM и NxN).

Обратите внимание, что подпрограмма возвращает матрицу V^T, а не V.

Входные параметры:
    A       -   разлагаемая матрица.
                Массив с нумерацией элементов [1..M, 1..N]
    M       -   число строк в матрице A
    N       -   число столбцов в матрице A
    UNeeded -   0, 1 или 2. Подробнее см. описание параметра U
    VTNeeded-   0, 1 или 2. Подробнее см. описание параметра V

Выходные параметры:
    W       -   содержит сингулярные значения, упорядоченные по убыванию.
    U       -   если UNeeded=0, не изменяется. Левые сингулярные   векторы
                не вычисляются.
                если UNeeded=1, содержит левые сингулярные векторы (первые
                min(M,N) столбцов матрицы U). Массив с нумерацией элементов
                [1..M, 1..Min(M,N)].
                если UNeeded=2, содержит полную матрицу U. Массив с нумера-
                цией элементов [1..M, 1..M].
    VT      -   если VTNeeded=0, не изменяется. Правые сингулярные векторы
                не вычисляются.
                если VTNeeded=1,  содержит   правые   сингулярные  векторы
                (первые min(M,N) строк матрицы V^T). Массив  с  нумерацией
                элементов [1..min(M,N), 1..N].
                если VTNeeded=2, содержит полную  матрицу  V^T.  Массив  с
                нумерацией элементов [1..N, 1..N].

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
bool svddecomposition(ap::real_2d_array a,
     int m,
     int n,
     int uneeded,
     int vtneeded,
     ap::real_1d_array& w,
     ap::real_2d_array& u,
     ap::real_2d_array& vt)
{
    bool result;
    ap::real_1d_array tauq;
    ap::real_1d_array taup;
    ap::real_1d_array tau;
    ap::real_1d_array e;
    ap::real_2d_array t;
    bool isupper;
    int minmn;
    int ncu;
    int nrvt;
    int nru;
    int ncvt;
    int i;
    int j;
    int im1;
    double sm;

    result = true;
    if( m==0||n==0 )
    {
        return result;
    }
    minmn = ap::minint(m, n);
    w.setbounds(1, minmn);
    ncu = 0;
    nru = 0;
    if( uneeded==1 )
    {
        nru = m;
        ncu = minmn;
        u.setbounds(1, nru, 1, ncu);
    }
    if( uneeded==2 )
    {
        nru = m;
        ncu = m;
        u.setbounds(1, nru, 1, ncu);
    }
    nrvt = 0;
    ncvt = 0;
    if( vtneeded==1 )
    {
        nrvt = minmn;
        ncvt = n;
        vt.setbounds(1, nrvt, 1, ncvt);
    }
    if( vtneeded==2 )
    {
        nrvt = n;
        ncvt = n;
        vt.setbounds(1, nrvt, 1, ncvt);
    }
    if( m>1.6*n )
    {
        if( uneeded==0 )
        {
            qrdecomposition(a, m, n, tau);
            for(i = 2; i <= n; i++)
            {
                for(j = 1; j <= i-1; j++)
                {
                    a(i,j) = 0;
                }
            }
            tobidiagonal(a, n, n, tauq, taup);
            unpackptfrombidiagonal(a, n, n, taup, nrvt, vt);
            unpackdiagonalsfrombidiagonal(a, n, n, isupper, w, e);
            result = bidiagonalsvddecomposition(w, e, n, isupper, false, u, 0, vt, ncvt);
            return result;
        }
        else
        {
            qrdecomposition(a, m, n, tau);
            unpackqfromqr(a, m, n, tau, ncu, u);
            for(i = 2; i <= n; i++)
            {
                for(j = 1; j <= i-1; j++)
                {
                    a(i,j) = 0;
                }
            }
            tobidiagonal(a, n, n, tauq, taup);
            unpackqfrombidiagonal(a, n, n, tauq, n, t);
            unpackptfrombidiagonal(a, n, n, taup, nrvt, vt);
            unpackdiagonalsfrombidiagonal(a, n, n, isupper, w, e);
            result = bidiagonalsvddecomposition(w, e, n, isupper, false, t, n, vt, ncvt);
            if( !result )
            {
                return result;
            }
            for(i = 1; i <= m; i++)
            {
                for(j = 1; j <= n; j++)
                {
                    sm = ap::vdotproduct(u.getrow(i, 1, n), t.getcolumn(j, 1, n));
                    a(i,j) = sm;
                }
            }
            for(j = 1; j <= n; j++)
            {
                ap::vmove(u.getcolumn(j, 1, m), a.getcolumn(j, 1, m));
            }
            return result;
        }
    }
    if( n>1.6*m )
    {
        if( vtneeded==0 )
        {
            lqdecomposition(a, m, n, tau);
            for(i = 1; i <= m-1; i++)
            {
                for(j = i+1; j <= m; j++)
                {
                    a(i,j) = 0;
                }
            }
            tobidiagonal(a, m, m, tauq, taup);
            unpackqfrombidiagonal(a, m, m, tauq, ncu, u);
            unpackdiagonalsfrombidiagonal(a, m, m, isupper, w, e);
            result = bidiagonalsvddecomposition(w, e, m, isupper, false, u, nru, vt, 0);
            return result;
        }
        else
        {
            lqdecomposition(a, m, n, tau);
            unpackqfromlq(a, m, n, tau, nrvt, vt);
            for(i = 1; i <= m-1; i++)
            {
                for(j = i+1; j <= m; j++)
                {
                    a(i,j) = 0;
                }
            }
            tobidiagonal(a, m, m, tauq, taup);
            unpackqfrombidiagonal(a, m, m, tauq, ncu, u);
            unpackptfrombidiagonal(a, m, m, taup, m, t);
            unpackdiagonalsfrombidiagonal(a, m, m, isupper, w, e);
            result = bidiagonalsvddecomposition(w, e, m, isupper, false, u, nru, t, m);
            if( !result )
            {
                return result;
            }
            for(j = 1; j <= n; j++)
            {
                for(i = 1; i <= m; i++)
                {
                    sm = ap::vdotproduct(t.getrow(i, 1, m), vt.getcolumn(j, 1, m));
                    a(i,j) = sm;
                }
            }
            for(i = 1; i <= m; i++)
            {
                ap::vmove(vt.getrow(i, 1, n), a.getrow(i, 1, n));
            }
            return result;
        }
    }
    tobidiagonal(a, m, n, tauq, taup);
    unpackqfrombidiagonal(a, m, n, tauq, ncu, u);
    unpackptfrombidiagonal(a, m, n, taup, nrvt, vt);
    unpackdiagonalsfrombidiagonal(a, m, n, isupper, w, e);
    result = bidiagonalsvddecomposition(w, e, minmn, isupper, false, u, nru, vt, ncvt);
    return result;
}

/*************************************************************************
Применение последовательности элементарных вращений к матрице

Алгоритм  умножает  матрицу слева   на  последовательность  преобразований
вращения, заданную массивами C и S. В зависимости от  параметра  IsForward
вращению подвергаются последовательно либо 1 и 2, 3 и 4 и т.д. строки (если
IsForward=True), либо N и N-1-ая, N-2 и N-3 и т.д. строки.

Преобразованию подвергается не вся матрица а только её часть (строки от M1
до M2, столбцы от N1 до N2). Элементы, не попавшие в указанную подматрицу,
остаются без изменений.

Входные параметры:
    IsForward   -   последовательность применения вращений
    M1,M2       -   преобразованию подвергаются строки от M1 до M2
    N1,N2       -   преобразованию подвергаются столбцы от N1 до N2
    C,S         -   коэффициенты преобразования.
                    Массив с нумерацией элементов [1..M2-M1]
    A           -   обрабатываемая матрица
    WORK        -   рабочий массив с нумерацией элементов [N1..N2]

Выходные параметры
    A           -   преобразованная матрица

Служебная подпрограмма
*************************************************************************/
void applyrotationsfromtheleft(bool isforward,
     int m1,
     int m2,
     int n1,
     int n2,
     const ap::real_1d_array& c,
     const ap::real_1d_array& s,
     ap::real_2d_array& a,
     ap::real_1d_array& work)
{
    int i;
    int j;
    int jp1;
    double ctemp;
    double stemp;

    if( m1>m2||n1>n2 )
    {
        return;
    }
    if( isforward )
    {
        for(j = m1; j <= m2-1; j++)
        {
            ctemp = c(j-m1+1);
            stemp = s(j-m1+1);
            if( ctemp!=1||stemp!=0 )
            {
                jp1 = j+1;
                ap::vmove(work.getvector(n1, n2), a.getrow(jp1, n1, n2), ctemp);
                ap::vsub(work.getvector(n1, n2), a.getrow(j, n1, n2), stemp);
                ap::vmul(a.getrow(j, n1, n2), ctemp);
                ap::vadd(a.getrow(j, n1, n2), a.getrow(jp1, n1, n2), stemp);
                ap::vmove(a.getrow(jp1, n1, n2), work.getvector(n1, n2));
            }
        }
    }
    else
    {
        for(j = m2-1; j >= m1; j--)
        {
            ctemp = c(j-m1+1);
            stemp = s(j-m1+1);
            if( ctemp!=1||stemp!=0 )
            {
                jp1 = j+1;
                ap::vmove(work.getvector(n1, n2), a.getrow(jp1, n1, n2), ctemp);
                ap::vsub(work.getvector(n1, n2), a.getrow(j, n1, n2), stemp);
                ap::vmul(a.getrow(j, n1, n2), ctemp);
                ap::vadd(a.getrow(j, n1, n2), a.getrow(jp1, n1, n2), stemp);
                ap::vmove(a.getrow(jp1, n1, n2), work.getvector(n1, n2));
            }
        }
    }
}


/*************************************************************************
Применение последовательности элементарных вращений к матрице

Алгоритм  умножает  матрицу справа   на  последовательность  преобразований
вращения, заданную массивами C и S. В зависимости от  параметра   IsForward
вращению подвергаются последовательно либо 1 и 2,  3  и  4  и т.д.  столбцы
(если IsForward=True), либо N-ый и N-1-ый, N-2-ой и N-3-ий и т.д. столбцы.

Преобразованию подвергается не вся матрица а только её часть (строки от M1
до M2, столбцы от N1 до N2). Элементы, не попавшие в указанную подматрицу,
остаются без изменений.

Входные параметры:
    IsForward   -   последовательность применения вращений
    M1,M2       -   преобразованию подвергаются строки от M1 до M2
    N1,N2       -   преобразованию подвергаются столбцы от N1 до N2
    C,S         -   коэффициенты преобразования.
                    Массив с нумерацией элементов [1..N2-N1]
    A           -   обрабатываемая матрица
    WORK        -   рабочий массив с нумерацией элементов [M1..M2]

Выходные параметры
    A           -   преобразованная матрица

Служебная подпрограмма
*************************************************************************/
void applyrotationsfromtheright(bool isforward,
     int m1,
     int m2,
     int n1,
     int n2,
     const ap::real_1d_array& c,
     const ap::real_1d_array& s,
     ap::real_2d_array& a,
     ap::real_1d_array& work)
{
    int i;
    int j;
    int jp1;
    double ctemp;
    double stemp;

    if( isforward )
    {
        for(j = n1; j <= n2-1; j++)
        {
            ctemp = c(j-n1+1);
            stemp = s(j-n1+1);
            if( ctemp!=1||stemp!=0 )
            {
                jp1 = j+1;
                ap::vmove(work.getvector(m1, m2), a.getcolumn(jp1, m1, m2), ctemp);
                ap::vsub(work.getvector(m1, m2), a.getcolumn(j, m1, m2), stemp);
                ap::vmul(a.getcolumn(j, m1, m2), ctemp);
                ap::vadd(a.getcolumn(j, m1, m2), a.getcolumn(jp1, m1, m2), stemp);
                ap::vmove(a.getcolumn(jp1, m1, m2), work.getvector(m1, m2));
            }
        }
    }
    else
    {
        for(j = n2-1; j >= n1; j--)
        {
            ctemp = c(j-n1+1);
            stemp = s(j-n1+1);
            if( ctemp!=1||stemp!=0 )
            {
                jp1 = j+1;
                ap::vmove(work.getvector(m1, m2), a.getcolumn(jp1, m1, m2), ctemp);
                ap::vsub(work.getvector(m1, m2), a.getcolumn(j, m1, m2), stemp);
                ap::vmul(a.getcolumn(j, m1, m2), ctemp);
                ap::vadd(a.getcolumn(j, m1, m2), a.getcolumn(jp1, m1, m2), stemp);
                ap::vmove(a.getcolumn(jp1, m1, m2), work.getvector(m1, m2));
            }
        }
    }
}


/*************************************************************************
Подпрограмма генерирует элементарное вращение, такое, что

[  CS  SN  ]  .  [ F ]  =  [ R ]
[ -SN  CS  ]     [ G ]     [ 0 ]

CS**2 + SN**2 = 1
*************************************************************************/
void generaterotation(double f, double g, double& cs, double& sn, double& r)
{
    int cnt;
    int i;
    double eps;
    double f1;
    double g1;

    if( g==0 )
    {
        cs = 1;
        sn = 0;
        r = f;
    }
    else
    {
        if( f==0 )
        {
            cs = 0;
            sn = 1;
            r = g;
        }
        else
        {
            f1 = f;
            g1 = g;
            r = sqrt(ap::sqr(f1)+ap::sqr(g1));
            cs = f1/r;
            sn = g1/r;
            if( fabs(f)>fabs(g)&&cs<0 )
            {
                cs = -cs;
                sn = -sn;
                r = -r;
            }
        }
    }
}

/*************************************************************************
Генерация элементарного преобразования отражения

Подпрограмма генерирует элементарное отражение H порядка N, такое, что для
заданного X выполняется следующее равенство:

    ( X(1) )   ( Beta )
H * (  ..  ) = (  0   )
    ( X(n) )   (  0   )
    
где
              ( V(1) )
H = 1 - Tau * (  ..  ) * ( V(1), ..., V(n) )
              ( V(n) )

причем первая компонента вектора V равна единице.
              
Входные параметры:
    X       -   вектор. Массив с нумерацией элементов [1..N]
    N       -   порядок отражения
    
Выходные параметры:
    X       -   компоненты с 2 по N замещается вектором V. Первая
                компонента замещается параметром Beta.
    Tau     -   скалярная величина Tau. Равно 0 (если вектор X - нулевой),
                в противном случае 1 <= Tau <= 2.

Данная подпрограмма является модификацией подпрограмм DLARFG из библиотеки
LAPACK. Функциональность аналогичная, но отсутствует  корректная обработка
случаев, когда промежуточные результаты вычислений  переполняют  разрядную
сетку.

  -- LAPACK auxiliary routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     September 30, 1994
*************************************************************************/
void generatereflection(ap::real_1d_array& x, int n, double& tau)
{
    int j;
    int knt;
    double alpha;
    double xnorm;
    double v;
    double safmin;
    double rsafmin;
    double beta;

    if( n<=1 )
    {
        tau = 0;
        return;
    }
    alpha = x(1);
    xnorm = ap::vdotproduct(x.getvector(2, n), x.getvector(2, n));
    xnorm = sqrt(xnorm);
    if( xnorm==0 )
    {
        tau = 0;
        return;
    }
    beta = -ap::sign(alpha)*sqrt(ap::sqr(alpha)+ap::sqr(xnorm));
    tau = (beta-alpha)/beta;
    v = double(1)/double(alpha-beta);
    ap::vmul(x.getvector(2, n), v);
    x(1) = beta;
}


/*************************************************************************
Применение элементарного отражения к прямоугольной матрице размером MxN

Алгоритм умножает слева матрицу на элементарное преобразование  отражения,
заданное    столбцом   V   и   скалярной   величиной   Tau  (см.  описание
GenerateReflection). Преобразованию подвергается не вся матрица, а  только
её часть (строки от M1 до M2, столбцы от N1 до N2). Элементы, не  попавшие
в указанную подматрицу, остаются без изменений.

Входные параметры:
    C   -   матрица,  к  которой  применяется  преобразование.
    Tau -   скаляр, задающий преобразование.
    V   -   столбец, задающий преобразование. Массив с нумерацией элементов
            [1..M2-M1+1]
    M1,M2   -   диапазон строк, затрагиваемых преобразованием
    N1,N2   -   диапазон столбцов, затрагиваемых преобразованием
    WORK    -   рабочий массив с нумерацией элементов от N1 до N2

Выходные параметры:
    C   -   результат умножения входной матрицы C на матрицу преобразования,
            заданного Tau и V. Если N1>N2 или M1>M2, то C не меняется.

  -- LAPACK auxiliary routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     September 30, 1994
*************************************************************************/
void applyreflectionfromtheleft(ap::real_2d_array& c,
     double tau,
     const ap::real_1d_array& v,
     int m1,
     int m2,
     int n1,
     int n2,
     ap::real_1d_array& work)
{
    double t;
    int i;
    int vm;

    if( tau==0||n1>n2||m1>m2 )
    {
        return;
    }
    vm = m2-m1+1;
    for(i = n1; i <= n2; i++)
    {
        work(i) = 0;
    }
    for(i = m1; i <= m2; i++)
    {
        t = v(i+1-m1);
        ap::vadd(work.getvector(n1, n2), c.getrow(i, n1, n2), t);
    }
    for(i = m1; i <= m2; i++)
    {
        t = v(i-m1+1)*tau;
        ap::vsub(c.getrow(i, n1, n2), work.getvector(n1, n2), t);
    }
}


/*************************************************************************
Применение элементарного отражения к прямоугольной матрице размером MxN

Алгоритм умножает справа матрицу на элементарное преобразование отражения,
заданное    столбцом   V   и   скалярной   величиной   Tau  (см.  описание
GenerateReflection). Преобразованию подвергается не вся матрица, а  только
её часть (строки от M1 до M2, столбцы от N1 до N2). Элементы, не  попавшие
в указанную подматрицу, остаются без изменений.

Входные параметры:
    C   -   матрица,  к  которой  применяется  преобразование.
    Tau -   скаляр, задающий преобразование.
    V   -   столбец, задающий преобразование. Массив с нумерацией элементов
            [1..N2-N1+1]
    M1,M2   -   диапазон строк, затрагиваемых преобразованием
    N1,N2   -   диапазон столбцов, затрагиваемых преобразованием
    WORK    -   рабочий массив с нумерацией элементов от M1 до M2

Выходные параметры:
    C   -   результат умножения входной матрицы C на матрицу преобразования,
            заданного Tau и V. Если N1>N2 или M1>M2, то C не меняется.

  -- LAPACK auxiliary routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     September 30, 1994
*************************************************************************/
void applyreflectionfromtheright(ap::real_2d_array& c,
     double tau,
     const ap::real_1d_array& v,
     int m1,
     int m2,
     int n1,
     int n2,
     ap::real_1d_array& work)
{
    double t;
    int i;
    int vm;

    if( tau==0||n1>n2||m1>m2 )
    {
        return;
    }
    vm = n2-n1+1;
    for(i = m1; i <= m2; i++)
    {
        t = ap::vdotproduct(c.getrow(i, n1, n2), v.getvector(1, vm));
        work(i) = t;
    }
    for(i = m1; i <= m2; i++)
    {
        t = work(i)*tau;
        ap::vsub(c.getrow(i, n1, n2), v.getvector(1, vm), t);
    }
}
/*************************************************************************
QR-разложение прямоугольной матрицы размером M x N

Входные параметры:
    A   -   матрица A. Нумерация элементов: [1..M, 1..N]
    M   -   число строк в матрице A
    N   -   число столбцов в матрице A

Выходные параметры:
    A   -   матрицы Q и R в компактной форме (см. ниже)
    Tau -   массив скалярных множителей, участвующих в формировании
            матрицы Q. Нумерация элементов [1.. Min(M,N)]
            
Матрица A представляется, как A = QR, где Q ортогональная матрица размером
M x M, а R  верхнетреугольная (или верхнетрапецоидальная) матрица размером
M x N.

После завершения работы подпрограммы на главной диагонали матрицы A и выше
располагаются элементы матрицы R. В массиве Tau и под  главной  диагональю
матрицы A располагаются элементы, формирующие матрицу Q, следующим способом:

Матрица Q представляется, как произведение элементарных отражений

Q = H(1)*H(2)*...*H(k),

где k = min(m,n), а каждое H(i) имеет вид

H(i) = 1 - tau * v * (v^T)

где tau скалярная величина, хранящаяся в Tau[I], а v - вещественный вектор
у которого v(1:i-1)=0, v(i)=1, v(i+1:m) хранится в элементах A(i+1:m,i).

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     February 29, 1992
*************************************************************************/
void qrdecomposition(ap::real_2d_array& a,
     int m,
     int n,
     ap::real_1d_array& tau)
{
    ap::real_1d_array work;
    ap::real_1d_array t;
    int i;
    int k;
    int mmip1;
    double aii;
    int minmn;
    double tmp;

    minmn = ap::minint(m, n);
    work.setbounds(1, n);
    t.setbounds(1, m);
    tau.setbounds(1, minmn);
    k = ap::minint(m, n);
    for(i = 1; i <= k; i++)
    {
        mmip1 = m-i+1;
        ap::vmove(t.getvector(1, mmip1), a.getcolumn(i, i, m));
        generatereflection(t, mmip1, tmp);
        tau(i) = tmp;
        ap::vmove(a.getcolumn(i, i, m), t.getvector(1, mmip1));
        t(1) = 1;
        if( i<n )
        {
            applyreflectionfromtheleft(a, tau(i), t, i, m, i+1, n, work);
        }
    }
}


/*************************************************************************
Частичная "распаковка" матрицы Q из QR-разложения матрицы A.

Входные параметры:
    QR      -   матрицы Q и R в упакованной форме.
                Результат работы QRDecomposition.
    M       -   число строк в оригинальной матрице A. M>=0
    N       -   число столбцов в оригинальной матрице A. N>=0
    Tau     -   скалярные множители, формирующие Q.
                Результат работы QRDecomposition.
    QColumns-   требуемое число столбцов матрицы Q. M>=QColumns>=0.

Выходные параметры:
    Q       -   первые QColumns столбцов матрицы Q. Массив с нумерацией
                элементов [1..M, 1..QColumns]. Если QColumns=0, то массив
                не изменяется.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
void unpackqfromqr(const ap::real_2d_array& qr,
     int m,
     int n,
     const ap::real_1d_array& tau,
     int qcolumns,
     ap::real_2d_array& q)
{
    int i;
    int j;
    int k;
    int minmn;
    ap::real_1d_array v;
    ap::real_1d_array work;
    int vm;

    ap::ap_error::make_assertion(qcolumns<=m);
    if( m==0||n==0||qcolumns==0 )
    {
        return;
    }
    minmn = ap::minint(m, n);
    k = ap::minint(minmn, qcolumns);
    q.setbounds(1, m, 1, qcolumns);
    v.setbounds(1, m);
    work.setbounds(1, qcolumns);
    for(i = 1; i <= m; i++)
    {
        for(j = 1; j <= qcolumns; j++)
        {
            if( i==j )
            {
                q(i,j) = 1;
            }
            else
            {
                q(i,j) = 0;
            }
        }
    }
    for(i = k; i >= 1; i--)
    {
        vm = m-i+1;
        ap::vmove(v.getvector(1, vm), qr.getcolumn(i, i, m));
        v(1) = 1;
        applyreflectionfromtheleft(q, tau(i), v, i, m, 1, qcolumns, work);
    }
}


/*************************************************************************
QR-разложение прямоугольной матрицы размера M x N

Использует  QRDecomposition.   По  функциональности  отличается  тем,  что
выводит  матрицы  Q  и  R не в компактной форме, а в виде отдельных матриц
общего вида. Соответственно, матрица  R  "распаковывается",  дополняясь  в
нужных местах нулевыми элементами, а матрица Q строится  как  произведение
составляющих её элементарных отражений.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
void qrdecompositionunpacked(ap::real_2d_array a,
     int m,
     int n,
     ap::real_2d_array& q,
     ap::real_2d_array& r)
{
    int i;
    int j;
    int k;
    int l;
    int vm;
    ap::real_1d_array tau;
    ap::real_1d_array work;
    ap::real_1d_array v;
    double tmp;

    k = ap::minint(m, n);
    if( n<=0 )
    {
        return;
    }
    work.setbounds(1, m);
    v.setbounds(1, m);
    q.setbounds(1, m, 1, m);
    r.setbounds(1, m, 1, n);
    qrdecomposition(a, m, n, tau);
    for(i = 1; i <= n; i++)
    {
        r(1,i) = 0;
    }
    for(i = 2; i <= m; i++)
    {
        ap::vmove(r.getrow(i, 1, n), r.getrow(1, 1, n));
    }
    for(i = 1; i <= k; i++)
    {
        ap::vmove(r.getrow(i, i, n), a.getrow(i, i, n));
    }
    unpackqfromqr(a, m, n, tau, m, q);
}


/*************************************************************************
LQ-разложение прямоугольной матрицы размером M x N

Входные параметры:
    A   -   матрица A. Нумерация элементов: [1..M, 1..N]
    M   -   число строк в матрице A
    N   -   число столбцов в матрице A

Выходные параметры:
    A   -   матрицы L и Q в компактной форме (см. ниже)
    Tau -   массив скалярных множителей, участвующих в формировании
            матрицы Q. Нумерация элементов [1.. Min(M,N)]
            
Матрица A представляется, как A = LQ, где Q ортогональная матрица размером
M x M, а R  нижнетреугольная  (или  нижнетрапецоидальная) матрица размером
M x N.

После завершения работы подпрограммы на главной диагонали матрицы A и ниже
располагаются элементы матрицы L. В массиве Tau и над  главной  диагональю
матрицы A располагаются элементы, формирующие матрицу Q, следующим способом:

Матрица Q представляется, как произведение элементарных отражений

Q = H(k)*H(k-1)*...*H(2)*H(1),

где k = min(m,n), а каждое H(i) имеет вид

H(i) = 1 - tau * v * (v^T)

где tau скалярная величина, хранящаяся в Tau[I], а v - вещественный вектор
у которого v(1:i-1)=0, v(i)=1, v(i+1:n) хранится в элементах A(i,i+1:n).

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
void lqdecomposition(ap::real_2d_array& a,
     int m,
     int n,
     ap::real_1d_array& tau)
{
    ap::real_1d_array work;
    ap::real_1d_array t;
    int i;
    int k;
    int nmip1;
    double aii;
    int minmn;
    int maxmn;
    double tmp;

    minmn = ap::minint(m, n);
    maxmn = ap::maxint(m, n);
    work.setbounds(1, m);
    t.setbounds(1, n);
    tau.setbounds(1, minmn);
    k = ap::minint(m, n);
    for(i = 1; i <= k; i++)
    {
        nmip1 = n-i+1;
        ap::vmove(t.getvector(1, nmip1), a.getrow(i, i, n));
        generatereflection(t, nmip1, tmp);
        tau(i) = tmp;
        ap::vmove(a.getrow(i, i, n), t.getvector(1, nmip1));
        t(1) = 1;
        if( i<n )
        {
            applyreflectionfromtheright(a, tau(i), t, i+1, m, i, n, work);
        }
    }
}


/*************************************************************************
Частичная "распаковка" матрицы Q из LQ-разложения матрицы A.

Входные параметры:
    LQ      -   матрицы L и Q в упакованной форме.
                Результат работы LQDecomposition.
    M       -   число строк в оригинальной матрице A. M>=0
    N       -   число столбцов в оригинальной матрице A. N>=0
    Tau     -   скалярные множители, формирующие Q.
                Результат работы LQDecomposition.
    QRows   -   требуемое число строк матрицы Q. N>=QRows>=0.

Выходные параметры:
    Q       -   первые QRows строк матрицы Q. Массив с нумерацией
                элементов [1..QRows, 1..N]. Если QRows=0, то массив
                не изменяется.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
void unpackqfromlq(const ap::real_2d_array& lq,
     int m,
     int n,
     const ap::real_1d_array& tau,
     int qrows,
     ap::real_2d_array& q)
{
    int i;
    int j;
    int k;
    int minmn;
    ap::real_1d_array v;
    ap::real_1d_array work;
    int vm;

    ap::ap_error::make_assertion(qrows<=n);
    if( m==0||n==0||qrows==0 )
    {
        return;
    }
    minmn = ap::minint(m, n);
    k = ap::minint(minmn, qrows);
    q.setbounds(1, qrows, 1, n);
    v.setbounds(1, n);
    work.setbounds(1, qrows);
    for(i = 1; i <= qrows; i++)
    {
        for(j = 1; j <= n; j++)
        {
            if( i==j )
            {
                q(i,j) = 1;
            }
            else
            {
                q(i,j) = 0;
            }
        }
    }
    for(i = k; i >= 1; i--)
    {
        vm = n-i+1;
        ap::vmove(v.getvector(1, vm), lq.getrow(i, i, n));
        v(1) = 1;
        applyreflectionfromtheright(q, tau(i), v, 1, qrows, i, n, work);
    }
}


/*************************************************************************
LQ-разложение прямоугольной матрицы размера M x N

Использует  LQDecomposition.   По  функциональности  отличается  тем,  что
выводит  матрицы  L  и  Q не в компактной форме, а в виде отдельных матриц
общего вида. Соответственно, матрица  L  "распаковывается",  дополняясь  в
нужных местах нулевыми элементами, а матрица Q строится  как  произведение
составляющих её элементарных отражений.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
void lqdecompositionunpacked(ap::real_2d_array a,
     int m,
     int n,
     ap::real_2d_array& l,
     ap::real_2d_array& q)
{
    int i;
    int j;
    ap::real_1d_array tau;
    double tmp;

    if( n<=0 )
    {
        return;
    }
    q.setbounds(1, n, 1, n);
    l.setbounds(1, m, 1, n);
    lqdecomposition(a, m, n, tau);
    for(i = 1; i <= m; i++)
    {
        for(j = 1; j <= n; j++)
        {
            if( j>i )
            {
                l(i,j) = 0;
            }
            else
            {
                l(i,j) = a(i,j);
            }
        }
    }
    unpackqfromlq(a, m, n, tau, n, q);
}
/*************************************************************************
Сингулярное разложение двухдиагональной матрицы

Алгоритм  осуществляет  сингулярное  разложение двухдиагональной матрицы B
(верхней или нижней), представляя её в виде B = Q * S * P^T, где Q и  P  -
ортогональные матрицы, S - диагональная с неотрицательными  элементами  на
главной диагонали, расположенными в порядке убывания.

Алгоритм находит сингулярные значения. Дополнительно алгоритм может вычислять
матрицы Q и P (точнее, не сами матрицы, а их произведения на заданные матрицы
U и VT - U*Q и (P^T)*VT)). Разумеется, матрицы U и VT  могут  быть  какими
угодно, в том числе и единичными.

Особенностью алгоритма  является   возможность  находить  ВСЕ  сингулярные
значения,  в  том  числе  и  сколь  угодно близкие к нолю, с относительной
точностью, близкой к машинной. Если параметр  IsFractionalAccuracyRequired
равен True, то все сингулярные значения находятся с высокой  относительной
точностью, близкой к машинной. Если параметр равен False, то с  точностью,
близкой к машинной, находятся лишь самое большое сингулярное значение,   а
абсолютная погрешность остальных  сингулярных  значений  равна  абсолютной
погрешности самого большого сингулярного значения.

Входные параметры:
    D   -       главная диагональ матрицы B.
                Массив с нумерацией элементов [1..N]
    E   -       наддиагональ (или поддиагональ) матрицы B.
                Массив с нумерацией элементов [1..N-1]
    N   -       размер матрицы B
    IsUpper-    True, если матрица верхняя двухдиагональная.
    IsFractionalAccuracyRequired-
                с какой точностью надо искать сингулярные значения
    U   -       матрица, которая будет  умножена на матрицу  Q.  Массив  с
                нумерацией элементов [1..NRU, 1..N].  Матрица  может  быть
                больше, в таком случае  лишь  указанная  подматрица  будет
                умножена на матрицу Q.
    NRU -       число строк в матрице U
    VT  -       матрица, которая будет  умножена на матрицу  P^T. Массив с
                нумерацией элементов [1..N, 1..NCVT]. Матрица  может  быть
                больше, в таком случае  лишь  указанная  подматрица  будет
                умножена на матрицу P^T.
    NCVT-       число столбцов в матрице VT.

Выходные параметры:
    D   -       сингулярные значения матрицы B, упорядоченные по убыванию.
    U   -       если NRU>0, содержит матрицу U*Q
    VT  -       если NCVT>0, содержит матрицу (P^T)*VT

Дополнительная информация:
    тип сходимости контролируется внутренним параметром TOL. Если параметр
    больше   ноля,  то  сингулярные  значения  находятся  с  относительной
    погрешностью TOL. Если TOL<0, сингулярные значения находятся с
    абсолютной погрешностью ABS(TOL)*norm(B).
    По умолчанию |TOL| находится в интервале от 10*Epsilon до 100*Epsilon,
    где Epsilon - машинная точность. Не рекомендуется делать  TOL  меньше,
    чем 10*Epsilon, поскольку это сушественно  замедлит  алгоритм,  но  не
    обязательно приведет к дальнейшему уменьшению погрешности.

  -- LAPACK routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     October 31, 1999
*************************************************************************/
bool bidiagonalsvddecomposition(ap::real_1d_array& d,
     ap::real_1d_array e,
     int n,
     bool isupper,
     bool isfractionalaccuracyrequired,
     ap::real_2d_array& u,
     int nru,
     ap::real_2d_array& vt,
     int ncvt)
{
    bool result;
    int i;
    int idir;
    int isub;
    int iter;
    int j;
    int ll;
    int lll;
    int m;
    int maxit;
    int nm1;
    int nm12;
    int nm13;
    int oldll;
    int oldm;
    double abse;
    double abss;
    double cosl;
    double cosr;
    double cs;
    double eps;
    double f;
    double g;
    double h;
    double mu;
    double oldcs;
    double oldsn;
    double r;
    double shift;
    double sigmn;
    double sigmx;
    double sinl;
    double sinr;
    double sll;
    double smax;
    double smin;
    double sminl;
    double sminlo;
    double sminoa;
    double sn;
    double thresh;
    double tol;
    double tolmul;
    double unfl;
    ap::real_1d_array work0;
    ap::real_1d_array work1;
    ap::real_1d_array work2;
    ap::real_1d_array work3;
    int maxitr;
    bool matrixsplitflag;
    bool iterflag;
    ap::real_1d_array utemp;
    ap::real_1d_array vttemp;
    ap::real_1d_array etemp;
    bool rightside;
    bool fwddir;
    double tmp;
    int mm1;

    result = true;
    if( n==0 )
    {
        return result;
    }
    if( n==1 )
    {
        if( d(1)<0 )
        {
            d(1) = -d(1);
            if( ncvt>0 )
            {
                ap::vmul(vt.getrow(1, 1, ncvt), -1);
            }
        }
        return result;
    }
    work0.setbounds(1, n-1);
    work1.setbounds(1, n-1);
    work2.setbounds(1, n-1);
    work3.setbounds(1, n-1);
    utemp.setbounds(1, ap::maxint(nru, 1));
    vttemp.setbounds(1, ap::maxint(ncvt, 1));
    maxitr = 6;
    rightside = true;
    fwddir = true;
    etemp.setbounds(1, n);
    for(i = 1; i <= n-1; i++)
    {
        etemp(i) = e(i);
    }
    e.setbounds(1, n);
    for(i = 1; i <= n-1; i++)
    {
        e(i) = etemp(i);
    }
    e(n) = 0;
    nm1 = n-1;
    nm12 = nm1+nm1;
    nm13 = nm12+nm1;
    idir = 0;
    eps = ap::machineepsilon;
    unfl = ap::minrealnumber;
    if( !isupper )
    {
        for(i = 1; i <= n-1; i++)
        {
            generaterotation(d(i), e(i), cs, sn, r);
            d(i) = r;
            e(i) = sn*d(i+1);
            d(i+1) = cs*d(i+1);
            work0(i) = cs;
            work1(i) = sn;
        }
        if( nru>0 )
        {
            applyrotationsfromtheright(fwddir, 1, nru, 1, n, work0, work1, u, utemp);
        }
    }
    tolmul = ap::maxreal(10, ap::minreal(100, pow(eps, -0.125)));
    tol = tolmul*eps;
    if( !isfractionalaccuracyrequired )
    {
        tol = -tol;
    }
    smax = 0;
    for(i = 1; i <= n; i++)
    {
        smax = ap::maxreal(smax, fabs(d(i)));
    }
    for(i = 1; i <= n-1; i++)
    {
        smax = ap::maxreal(smax, fabs(e(i)));
    }
    sminl = 0;
    if( tol>=0 )
    {
        sminoa = fabs(d(1));
        if( sminoa!=0 )
        {
            mu = sminoa;
            for(i = 2; i <= n; i++)
            {
                mu = fabs(d(i))*(mu/(mu+fabs(e(i-1))));
                sminoa = ap::minreal(sminoa, mu);
                if( sminoa==0 )
                {
                    break;
                }
            }
        }
        sminoa = sminoa/sqrt(n);
        thresh = ap::maxreal(tol*sminoa, maxitr*n*n*unfl);
    }
    else
    {
        thresh = ap::maxreal(fabs(tol)*smax, maxitr*n*n*unfl);
    }
    maxit = maxitr*n*n;
    iter = 0;
    oldll = -1;
    oldm = -1;
    m = n;
    while(true)
    {
        if( m<=1 )
        {
            break;
        }
        if( iter>maxit )
        {
            result = false;
            return result;
        }
        if( tol<0&&fabs(d(m))<=thresh )
        {
            d(m) = 0;
        }
        smax = fabs(d(m));
        smin = smax;
        matrixsplitflag = false;
        for(lll = 1; lll <= m-1; lll++)
        {
            ll = m-lll;
            abss = fabs(d(ll));
            abse = fabs(e(ll));
            if( tol<0&&abss<=thresh )
            {
                d(ll) = 0;
            }
            if( abse<=thresh )
            {
                matrixsplitflag = true;
                break;
            }
            smin = ap::minreal(smin, abss);
            smax = ap::maxreal(smax, ap::maxreal(abss, abse));
        }
        if( !matrixsplitflag )
        {
            ll = 0;
        }
        else
        {
            e(ll) = 0;
            if( ll==m-1 )
            {
                m = m-1;
                continue;
            }
        }
        ll = ll+1;
        if( ll==m-1 )
        {
            svdv2x2(d(m-1), e(m-1), d(m), sigmn, sigmx, sinr, cosr, sinl, cosl);
            d(m-1) = sigmx;
            e(m-1) = 0;
            d(m) = sigmn;
            if( ncvt>0 )
            {
                mm1 = m-1;
                ap::vmove(vttemp.getvector(1, ncvt), vt.getrow(mm1, 1, ncvt), cosr);
                ap::vadd(vttemp.getvector(1, ncvt), vt.getrow(m, 1, ncvt), sinr);
                ap::vmul(vt.getrow(m, 1, ncvt), cosr);
                ap::vsub(vt.getrow(m, 1, ncvt), vt.getrow(mm1, 1, ncvt), sinr);
                ap::vmove(vt.getrow(mm1, 1, ncvt), vttemp.getvector(1, ncvt));
            }
            if( nru>0 )
            {
                mm1 = m-1;
                ap::vmove(utemp.getvector(1, nru), u.getcolumn(mm1, 1, nru), cosl);
                ap::vadd(utemp.getvector(1, nru), u.getcolumn(m, 1, nru), sinl);
                ap::vmul(u.getcolumn(m, 1, nru), cosl);
                ap::vsub(u.getcolumn(m, 1, nru), u.getcolumn(mm1, 1, nru), sinl);
                ap::vmove(u.getcolumn(mm1, 1, nru), utemp.getvector(1, nru));
            }
            m = m-2;
            continue;
        }
        if( ll>oldm||m<oldll )
        {
            if( fabs(d(ll))>=fabs(d(m)) )
            {
                idir = 1;
            }
            else
            {
                idir = 2;
            }
        }
        if( idir==1 )
        {
            if( fabs(e(m-1))<=fabs(tol)*fabs(d(m))||tol<0&&fabs(e(m-1))<=thresh )
            {
                e(m-1) = 0;
                continue;
            }
            if( tol>=0 )
            {
                mu = fabs(d(ll));
                sminl = mu;
                iterflag = false;
                for(lll = ll; lll <= m-1; lll++)
                {
                    if( fabs(e(lll))<=tol*mu )
                    {
                        e(lll) = 0;
                        iterflag = true;
                        break;
                    }
                    sminlo = sminl;
                    mu = fabs(d(lll+1))*(mu/(mu+fabs(e(lll))));
                    sminl = ap::minreal(sminl, mu);
                }
                if( iterflag )
                {
                    continue;
                }
            }
        }
        else
        {
            if( fabs(e(ll))<=fabs(tol)*fabs(d(ll))||tol<0&&fabs(e(ll))<=thresh )
            {
                e(ll) = 0;
                continue;
            }
            if( tol>=0 )
            {
                mu = fabs(d(m));
                sminl = mu;
                iterflag = false;
                for(lll = m-1; lll >= ll; lll--)
                {
                    if( fabs(e(lll))<=tol*mu )
                    {
                        e(lll) = 0;
                        iterflag = true;
                        break;
                    }
                    sminlo = sminl;
                    mu = fabs(d(lll))*(mu/(mu+fabs(e(lll))));
                    sminl = ap::minreal(sminl, mu);
                }
                if( iterflag )
                {
                    continue;
                }
            }
        }
        oldll = ll;
        oldm = m;
        if( tol>=0&&n*tol*(sminl/smax)<=ap::maxreal(eps, 0.01*tol) )
        {
            shift = 0;
        }
        else
        {
            if( idir==1 )
            {
                sll = fabs(d(ll));
                svd2x2(d(m-1), e(m-1), d(m), shift, r);
            }
            else
            {
                sll = fabs(d(m));
                svd2x2(d(ll), e(ll), d(ll+1), shift, r);
            }
            if( sll>0 )
            {
                if( ap::sqr(shift/sll)<eps )
                {
                    shift = 0;
                }
            }
        }
        iter = iter+m-ll;
        if( shift==0 )
        {
            if( idir==1 )
            {
                cs = 1;
                oldcs = 1;
                for(i = ll; i <= m-1; i++)
                {
                    generaterotation(d(i)*cs, e(i), cs, sn, r);
                    if( i>ll )
                    {
                        e(i-1) = oldsn*r;
                    }
                    generaterotation(oldcs*r, d(i+1)*sn, oldcs, oldsn, tmp);
                    d(i) = tmp;
                    work0(i-ll+1) = cs;
                    work1(i-ll+1) = sn;
                    work2(i-ll+1) = oldcs;
                    work3(i-ll+1) = oldsn;
                }
                h = d(m)*cs;
                d(m) = h*oldcs;
                e(m-1) = h*oldsn;
                if( ncvt>0 )
                {
                    applyrotationsfromtheleft(fwddir, ll, m, 1, ncvt, work0, work1, vt, vttemp);
                }
                if( nru>0 )
                {
                    applyrotationsfromtheright(fwddir, 1, nru, ll, m, work2, work3, u, utemp);
                }
                if( fabs(e(m-1))<=thresh )
                {
                    e(m-1) = 0;
                }
            }
            else
            {
                cs = 1;
                oldcs = 1;
                for(i = m; i >= ll+1; i--)
                {
                    generaterotation(d(i)*cs, e(i-1), cs, sn, r);
                    if( i<m )
                    {
                        e(i) = oldsn*r;
                    }
                    generaterotation(oldcs*r, d(i-1)*sn, oldcs, oldsn, tmp);
                    d(i) = tmp;
                    work0(i-ll) = cs;
                    work1(i-ll) = -sn;
                    work2(i-ll) = oldcs;
                    work3(i-ll) = -oldsn;
                }
                h = d(ll)*cs;
                d(ll) = h*oldcs;
                e(ll) = h*oldsn;
                if( ncvt>0 )
                {
                    applyrotationsfromtheleft(!fwddir, ll, m, 1, ncvt, work2, work3, vt, vttemp);
                }
                if( nru>0 )
                {
                    applyrotationsfromtheright(!fwddir, 1, nru, ll, m, work0, work1, u, utemp);
                }
                if( fabs(e(ll))<=thresh )
                {
                    e(ll) = 0;
                }
            }
        }
        else
        {
            if( idir==1 )
            {
                f = (fabs(d(ll))-shift)*(extsignbdsqr(1, d(ll))+shift/d(ll));
                g = e(ll);
                for(i = ll; i <= m-1; i++)
                {
                    generaterotation(f, g, cosr, sinr, r);
                    if( i>ll )
                    {
                        e(i-1) = r;
                    }
                    f = cosr*d(i)+sinr*e(i);
                    e(i) = cosr*e(i)-sinr*d(i);
                    g = sinr*d(i+1);
                    d(i+1) = cosr*d(i+1);
                    generaterotation(f, g, cosl, sinl, r);
                    d(i) = r;
                    f = cosl*e(i)+sinl*d(i+1);
                    d(i+1) = cosl*d(i+1)-sinl*e(i);
                    if( i<m-1 )
                    {
                        g = sinl*e(i+1);
                        e(i+1) = cosl*e(i+1);
                    }
                    work0(i-ll+1) = cosr;
                    work1(i-ll+1) = sinr;
                    work2(i-ll+1) = cosl;
                    work3(i-ll+1) = sinl;
                }
                e(m-1) = f;
                if( ncvt>0 )
                {
                    applyrotationsfromtheleft(fwddir, ll, m, 1, ncvt, work0, work1, vt, vttemp);
                }
                if( nru>0 )
                {
                    applyrotationsfromtheright(fwddir, 1, nru, ll, m, work2, work3, u, utemp);
                }
                if( fabs(e(m-1))<=thresh )
                {
                    e(m-1) = 0;
                }
            }
            else
            {
                f = (fabs(d(m))-shift)*(extsignbdsqr(1, d(m))+shift/d(m));
                g = e(m-1);
                for(i = m; i >= ll+1; i--)
                {
                    generaterotation(f, g, cosr, sinr, r);
                    if( i<m )
                    {
                        e(i) = r;
                    }
                    f = cosr*d(i)+sinr*e(i-1);
                    e(i-1) = cosr*e(i-1)-sinr*d(i);
                    g = sinr*d(i-1);
                    d(i-1) = cosr*d(i-1);
                    generaterotation(f, g, cosl, sinl, r);
                    d(i) = r;
                    f = cosl*e(i-1)+sinl*d(i-1);
                    d(i-1) = cosl*d(i-1)-sinl*e(i-1);
                    if( i>ll+1 )
                    {
                        g = sinl*e(i-2);
                        e(i-2) = cosl*e(i-2);
                    }
                    work0(i-ll) = cosr;
                    work1(i-ll) = -sinr;
                    work2(i-ll) = cosl;
                    work3(i-ll) = -sinl;
                }
                e(ll) = f;
                if( fabs(e(ll))<=thresh )
                {
                    e(ll) = 0;
                }
                if( ncvt>0 )
                {
                    applyrotationsfromtheleft(!fwddir, ll, m, 1, ncvt, work2, work3, vt, vttemp);
                }
                if( nru>0 )
                {
                    applyrotationsfromtheright(!fwddir, 1, nru, ll, m, work0, work1, u, utemp);
                }
            }
        }
        continue;
    }
    for(i = 1; i <= n; i++)
    {
        if( d(i)<0 )
        {
            d(i) = -d(i);
            if( ncvt>0 )
            {
                ap::vmul(vt.getrow(i, 1, ncvt), -1);
            }
        }
    }
    for(i = 1; i <= n-1; i++)
    {
        isub = 1;
        smin = d(1);
        for(j = 2; j <= n+1-i; j++)
        {
            if( d(j)<=smin )
            {
                isub = j;
                smin = d(j);
            }
        }
        if( isub!=n+1-i )
        {
            d(isub) = d(n+1-i);
            d(n+1-i) = smin;
            if( ncvt>0 )
            {
                j = n+1-i;
                ap::vmove(vttemp.getvector(1, ncvt), vt.getrow(isub, 1, ncvt));
                ap::vmove(vt.getrow(isub, 1, ncvt), vt.getrow(j, 1, ncvt));
                ap::vmove(vt.getrow(j, 1, ncvt), vttemp.getvector(1, ncvt));
            }
            if( nru>0 )
            {
                j = n+1-i;
                ap::vmove(utemp.getvector(1, nru), u.getcolumn(isub, 1, nru));
                ap::vmove(u.getcolumn(isub, 1, nru), u.getcolumn(j, 1, nru));
                ap::vmove(u.getcolumn(j, 1, nru), utemp.getvector(1, nru));
            }
        }
    }
    return result;
}


/*************************************************************************
Передача знака. Служебная подпрограмма.
*************************************************************************/
double extsignbdsqr(double a, double b)
{
    double result;

    if( b>=0 )
    {
        result = fabs(a);
    }
    else
    {
        result = -fabs(a);
    }
    return result;
}


/*************************************************************************
Svd2X2  computes the singular values of the 2-by-2 matrix
   [  F   G  ]
   [  0   H  ].
On return, SSMIN is the smaller singular value and SSMAX is the
larger singular value.

  -- LAPACK auxiliary routine (version 3.0) --
     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,
     Courant Institute, Argonne National Lab, and Rice University
     September 30, 1994
*************************************************************************/
void svd2x2(double f, double g, double h, double& ssmin, double& ssmax)
{
    double aas;
    double at;
    double au;
    double c;
    double fa;
    double fhmn;
    double fhmx;
    double ga;
    double ha;

    fa = fabs(f);
    ga = fabs(g);
    ha = fabs(h);
    fhmn = ap::minreal(fa, ha);
    fhmx = ap::maxreal(fa, ha);
    if( fhmn==0 )
    {
        ssmin = 0;
        if( fhmx==0 )
        {
            ssmax = ga;
        }
        else
        {
            ssmax = ap::maxreal(fhmx, ga)*sqrt(1+ap::sqr(ap::minreal(fhmx, ga)/ap::maxreal(fhmx, ga)));
        }
    }
    else
    {
        if( ga<fhmx )
        {
            aas = 1+fhmn/fhmx;
            at = (fhmx-fhmn)/fhmx;
            au = ap::sqr(ga/fhmx);
            c = double(2)/double(sqrt(aas*aas+au)+sqrt(at*at+au));
            ssmin = fhmn*c;
            ssmax = fhmx/c;
        }
        else
        {
            au = fhmx/ga;
            if( au==0 )
            {
                ssmin = fhmn*fhmx/ga;
                ssmax = ga;
            }
            else
            {
                aas = 1+fhmn/fhmx;
                at = (fhmx-fhmn)/fhmx;
                c = double(1)/double(sqrt(1+ap::sqr(aas*au))+sqrt(1+ap::sqr(at*au)));
                ssmin = fhmn*c*au;
                ssmin = ssmin+ssmin;
                ssmax = ga/(c+c);
            }
        }
    }
}


/*************************************************************************
SvdV2X2 computes the singular value decomposition of a 2-by-2
triangular matrix
   [  F   G  ]
   [  0   H  ].
On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
right singular vectors for abs(SSMAX), giving the decomposition

   [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
   [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].
*************************************************************************/
void svdv2x2(double f,
     double g,
     double h,
     double& ssmin,
     double& ssmax,
     double& snr,
     double& csr,
     double& snl,
     double& csl)
{
    bool gasmal;
    bool swp;
    int pmax;
    double a;
    double clt;
    double crt;
    double d;
    double fa;
    double ft;
    double ga;
    double gt;
    double ha;
    double ht;
    double l;
    double m;
    double mm;
    double r;
    double s;
    double slt;
    double srt;
    double t;
    double temp;
    double tsign;
    double tt;
    double v;

    ft = f;
    fa = fabs(ft);
    ht = h;
    ha = fabs(h);
    pmax = 1;
    swp = ha>fa;
    if( swp )
    {
        pmax = 3;
        temp = ft;
        ft = ht;
        ht = temp;
        temp = fa;
        fa = ha;
        ha = temp;
    }
    gt = g;
    ga = fabs(gt);
    if( ga==0 )
    {
        ssmin = ha;
        ssmax = fa;
        clt = 1;
        crt = 1;
        slt = 0;
        srt = 0;
    }
    else
    {
        gasmal = true;
        if( ga>fa )
        {
            pmax = 2;
            if( fa/ga<ap::machineepsilon )
            {
                gasmal = false;
                ssmax = ga;
                if( ha>1 )
                {
                    v = ga/ha;
                    ssmin = fa/v;
                }
                else
                {
                    v = fa/ga;
                    ssmin = v*ha;
                }
                clt = 1;
                slt = ht/gt;
                srt = 1;
                crt = ft/gt;
            }
        }
        if( gasmal )
        {
            d = fa-ha;
            if( d==fa )
            {
                l = 1;
            }
            else
            {
                l = d/fa;
            }
            m = gt/ft;
            t = 2-l;
            mm = m*m;
            tt = t*t;
            s = sqrt(tt+mm);
            if( l==0 )
            {
                r = fabs(m);
            }
            else
            {
                r = sqrt(l*l+mm);
            }
            a = 0.5*(s+r);
            ssmin = ha/a;
            ssmax = fa*a;
            if( mm==0 )
            {
                if( l==0 )
                {
                    t = extsignbdsqr(2, ft)*extsignbdsqr(1, gt);
                }
                else
                {
                    t = gt/extsignbdsqr(d, ft)+m/t;
                }
            }
            else
            {
                t = (m/(s+t)+m/(r+l))*(1+a);
            }
            l = sqrt(t*t+4);
            crt = double(2)/double(l);
            srt = t/l;
            clt = (crt+srt*m)/a;
            v = ht/ft;
            slt = v*srt/a;
        }
    }
    if( swp )
    {
        csl = srt;
        snl = crt;
        csr = slt;
        snr = clt;
    }
    else
    {
        csl = clt;
        snl = slt;
        csr = crt;
        snr = srt;
    }
    if( pmax==1 )
    {
        tsign = extsignbdsqr(1, csr)*extsignbdsqr(1, csl)*extsignbdsqr(1, f);
    }
    if( pmax==2 )
    {
        tsign = extsignbdsqr(1, snr)*extsignbdsqr(1, csl)*extsignbdsqr(1, g);
    }
    if( pmax==3 )
    {
        tsign = extsignbdsqr(1, snr)*extsignbdsqr(1, snl)*extsignbdsqr(1, h);
    }
    ssmax = extsignbdsqr(ssmax, tsign);
    ssmin = extsignbdsqr(ssmin, tsign*extsignbdsqr(1, f)*extsignbdsqr(1, h));
}


/*************************************************************************
Приведение прямоугольной матрицы к двухдиагональному виду

Алгоритм  приводит   прямоугольную  матрицу  A  к  двухдиагональному  виду
ортогональными преобразованиями P и Q, такими, что A = Q*B*P'

Входные параметры:
    A   -   исходная матрица A. Массив с нумерацией элементов [1..M, 1..N]
    M   -   число строк в матрице
    N   -   число столбцов в матрице
    
Выходные параметры:
    A   -   матрицы Q, B, P в упакованной форме (см. ниже).
    TauQ-   скалярные множители, участвующие в формировании матрицы Q
    TauP-   скалярные множители, участвующие в формировании матрицы Q

В результате работы алгоритма главная диагональ матрицы A и одна из побочных
замещаются бидиагональной матрицей B, а  в  остальных  элементах  хранятся
элементарные  отражения,  формирующие  матрицы  Q  и  P размером MxM и NxN
соответственно.

Если M>=N, то матрица B - верхняя двухдиагональная размером MxN и хранится
в соответствующих элементах матрицы A. Матрица  Q  представляется  в  виде
произведения элементарных  отражений  Q = H(1)*H(2)*...*H(n),  где  H(i) =
= 1 - tau*v*v'.  Здесь  tau  -  скалярная  величина, хранящая в TauQ[i], а
вектор v имеет следующую структуру: v(1:i-1)=0, v(i)=1, v(i+1:m)  хранится
в элементах A(i+1:m,i). Матрица P имеет вид P = G(1)*G(2)*...*G(n-1),  где
G(i) = 1 - tau*u*u'. Tau хранится в TauP[i], u(1:i)=0, u(i+1)=1,  u(i+2:n)
хранится в элементах A(i,i+2:n).

Если M<N, то матрица B - нижняя двухдиагональная размером MxN, и  хранится
в  соответствующих  элементах  матрицы  A.  Q = H(1)*H(2)*...*H(m-1),  где
H(i) = 1 - tau*v*v',  tau  хранится  в  TauQ, v(1:i)=0, v(i+1)=1, v(i+2:m)
хранится в A(i+2:m,i).  P = G(1)*G(2)*...*G(m),  G(i) = 1 - tau*u*u',  tau
хранится в TauP,  u(1:i-1)=0, u(i)=1, u(i+1:n) хранится в A(i,i+1:n).

ПРИМЕР:

m=6, n=5 (m > n):               m=5, n=6 (m < n):

(  d   e   u1  u1  u1 )         (  d   u1  u1  u1  u1  u1 )
(  v1  d   e   u2  u2 )         (  e   d   u2  u2  u2  u2 )
(  v1  v2  d   e   u3 )         (  v1  e   d   u3  u3  u3 )
(  v1  v2  v3  d   e  )         (  v1  v2  e   d   u4  u4 )
(  v1  v2  v3  v4  d  )         (  v1  v2  v3  e   d   u5 )
(  v1  v2  v3  v4  v5 )

здесь vi и ui обозначает векторы, формирующие H(i) и G(i), а d и e -
диагональные и внедиагональные элементы матрицы B.
*************************************************************************/
void tobidiagonal(ap::real_2d_array& a,
     int m,
     int n,
     ap::real_1d_array& tauq,
     ap::real_1d_array& taup)
{
    ap::real_1d_array work;
    ap::real_1d_array t;
    int minmn;
    int maxmn;
    int i;
    double ltau;
    int mmip1;
    int nmi;
    int ip1;
    int nmip1;
    int mmi;

    minmn = ap::minint(m, n);
    maxmn = ap::maxint(m, n);
    work.setbounds(1, maxmn);
    t.setbounds(1, maxmn);
    taup.setbounds(1, minmn);
    tauq.setbounds(1, minmn);
    if( m>=n )
    {
        for(i = 1; i <= n; i++)
        {
            mmip1 = m-i+1;
            ap::vmove(t.getvector(1, mmip1), a.getcolumn(i, i, m));
            generatereflection(t, mmip1, ltau);
            tauq(i) = ltau;
            ap::vmove(a.getcolumn(i, i, m), t.getvector(1, mmip1));
            t(1) = 1;
            applyreflectionfromtheleft(a, ltau, t, i, m, i+1, n, work);
            if( i<n )
            {
                nmi = n-i;
                ip1 = i+1;
                ap::vmove(t.getvector(1, nmi), a.getrow(i, ip1, n));
                generatereflection(t, nmi, ltau);
                taup(i) = ltau;
                ap::vmove(a.getrow(i, ip1, n), t.getvector(1, nmi));
                t(1) = 1;
                applyreflectionfromtheright(a, ltau, t, i+1, m, i+1, n, work);
            }
            else
            {
                taup(i) = 0;
            }
        }
    }
    else
    {
        for(i = 1; i <= m; i++)
        {
            nmip1 = n-i+1;
            ap::vmove(t.getvector(1, nmip1), a.getrow(i, i, n));
            generatereflection(t, nmip1, ltau);
            taup(i) = ltau;
            ap::vmove(a.getrow(i, i, n), t.getvector(1, nmip1));
            t(1) = 1;
            applyreflectionfromtheright(a, ltau, t, i+1, m, i, n, work);
            if( i<m )
            {
                mmi = m-i;
                ip1 = i+1;
                ap::vmove(t.getvector(1, mmi), a.getcolumn(i, ip1, m));
                generatereflection(t, mmi, ltau);
                tauq(i) = ltau;
                ap::vmove(a.getcolumn(i, ip1, m), t.getvector(1, mmi));
                t(1) = 1;
                applyreflectionfromtheleft(a, ltau, t, i+1, m, i+1, n, work);
            }
            else
            {
                tauq(i) = 0;
            }
        }
    }
}


/*************************************************************************
Частичная "распаковка" матрицы Q, приводящей матрицу  A к двухдиагональной
форме.

Входные параметры:
    QP      -   матрицы Q и P в упакованной форме.
                Результат работы подпрограммы ToBidiagonal.
    M       -   число строк в матрице A
    N       -   число столбцов в матрице A
    TAUQ    -   скалярные множители, формирующие матрицу Q.
                Результат работы подпрограммы ToBidiagonal.
    QColumns-   требуемое число столбцов матрицы Q. M >= QColumns >= 0

Выходные параметры:
    Q       -   QColumns первых столбцов матрицы Q.
                Массив с нумерацией элементов [1..M, 1..QColumns]
                Если QColumns=0, то массив не изменяется.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
void unpackqfrombidiagonal(const ap::real_2d_array& qp,
     int m,
     int n,
     const ap::real_1d_array& tauq,
     int qcolumns,
     ap::real_2d_array& q)
{
    int i;
    int j;
    int ip1;
    ap::real_1d_array v;
    ap::real_1d_array work;
    int vm;

    ap::ap_error::make_assertion(qcolumns<=m);
    if( m==0||n==0||qcolumns==0 )
    {
        return;
    }
    q.setbounds(1, m, 1, qcolumns);
    v.setbounds(1, m);
    work.setbounds(1, qcolumns);
    for(i = 1; i <= m; i++)
    {
        for(j = 1; j <= qcolumns; j++)
        {
            if( i==j )
            {
                q(i,j) = 1;
            }
            else
            {
                q(i,j) = 0;
            }
        }
    }
    if( m>=n )
    {
        for(i = ap::minint(n, qcolumns); i >= 1; i--)
        {
            vm = m-i+1;
            ap::vmove(v.getvector(1, vm), qp.getcolumn(i, i, m));
            v(1) = 1;
            applyreflectionfromtheleft(q, tauq(i), v, i, m, 1, qcolumns, work);
        }
    }
    else
    {
        for(i = ap::minint(m-1, qcolumns-1); i >= 1; i--)
        {
            vm = m-i;
            ip1 = i+1;
            ap::vmove(v.getvector(1, vm), qp.getcolumn(i, ip1, m));
            v(1) = 1;
            applyreflectionfromtheleft(q, tauq(i), v, i+1, m, 1, qcolumns, work);
        }
    }
}


/*************************************************************************
Частичная "распаковка" матрицы P, приводящей матрицу  A к двухдиагональной
форме. Подпрограмма выводит транспонированную матрицу P.

Входные параметры:
    QP      -   матрицы Q и P в упакованной форме.
                Результат работы подпрограммы ToBidiagonal.
    M       -   число строк в матрице A
    N       -   число столбцов в матрице A
    TAUP    -   скалярные множители, формирующие матрицу P.
                Результат работы подпрограммы ToBidiagonal.
    PTRows  -   требуемое число строк матрицы P^T. N >= PTRows >= 0

Выходные параметры:
    PT      -   PTRows первых столбцов матрицы PT.
                Массив с нумерацией элементов [1..PTRows, 1..N]
                Если PTRows=0, то массив не изменяется.


  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
void unpackptfrombidiagonal(const ap::real_2d_array& qp,
     int m,
     int n,
     const ap::real_1d_array& taup,
     int ptrows,
     ap::real_2d_array& pt)
{
    int i;
    int j;
    int ip1;
    ap::real_1d_array v;
    ap::real_1d_array work;
    int vm;

    ap::ap_error::make_assertion(ptrows<=n);
    if( m==0||n==0||ptrows==0 )
    {
        return;
    }
    pt.setbounds(1, ptrows, 1, n);
    v.setbounds(1, n);
    work.setbounds(1, ptrows);
    for(i = 1; i <= ptrows; i++)
    {
        for(j = 1; j <= n; j++)
        {
            if( i==j )
            {
                pt(i,j) = 1;
            }
            else
            {
                pt(i,j) = 0;
            }
        }
    }
    if( m>=n )
    {
        for(i = ap::minint(n-1, ptrows-1); i >= 1; i--)
        {
            vm = n-i;
            ip1 = i+1;
            ap::vmove(v.getvector(1, vm), qp.getrow(i, ip1, n));
            v(1) = 1;
            applyreflectionfromtheright(pt, taup(i), v, 1, ptrows, i+1, n, work);
        }
    }
    else
    {
        for(i = ap::minint(m, ptrows); i >= 1; i--)
        {
            vm = n-i+1;
            ap::vmove(v.getvector(1, vm), qp.getrow(i, i, n));
            v(1) = 1;
            applyreflectionfromtheright(pt, taup(i), v, 1, ptrows, i, n, work);
        }
    }
}


/*************************************************************************
"Распаковка" главной и побочной диагоналей двухдиагонального разложения
матрицы A.

Входные параметры:
    B       -   Результат работы подпрограммы ToBidiagonal.
    M       -   число строк в матрице B
    N       -   число столбцов в матрице B

Выходные параметры:
    IsUpper -   если матрица верхняя двухдиагональная, то True,
                иначе - False.
    D       -   главная диагональ.
                Массив с нумерацией элементов [1..Min(M,N)]
    E       -   побочная диагональ (верхняя или нижняя, в зависимости от
                параметра IsUpper).
                Массив с нумерацией элементов [1..Min(M,N)],   последний
                элемент не используется.

  -- ALGLIB --
     Copyright 2005 by Bochkanov Sergey
*************************************************************************/
void unpackdiagonalsfrombidiagonal(const ap::real_2d_array& b,
     int m,
     int n,
     bool& isupper,
     ap::real_1d_array& d,
     ap::real_1d_array& e)
{
    int i;

    isupper = m>=n;
    if( m==0||n==0 )
    {
        return;
    }
    if( isupper )
    {
        d.setbounds(1, n);
        e.setbounds(1, n);
        for(i = 1; i <= n-1; i++)
        {
            d(i) = b(i,i);
            e(i) = b(i,i+1);
        }
        d(n) = b(n,n);
    }
    else
    {
        d.setbounds(1, m);
        e.setbounds(1, m);
        for(i = 1; i <= m-1; i++)
        {
            d(i) = b(i,i);
            e(i) = b(i+1,i);
        }
        d(m) = b(m,m);
    }
}








